restart
load "../../Goettingen-2011/parallel/parallel.m2"

-- benchmark code
needsPackage "Markov"

-- If you have enough memory 2(# of cpus)+1 is OK.
allowableThreads = 3


jobs = for t in 1..50 list (
     R := ZZ/101[p_(1,1,1,1)..p_(3,3,2,2)];
     I := ideal(-p_(1,2,1,1)*p_(2,1,1,1)+p_(1,1,1,1)*p_(2,2,1,1),-p_(1,2,1,1)*p_(3,1,1,1)+p_(1,1,1,1)*p_(3,2,1,1),-p_(2,2,1,1)*p_(3,1,1,1)+p_(2,1,1,1)*p_(3,2,1,1),-p_(1,3,1,1)*p_(2,1,1,1)+p_(1,1,1,1)*p_(2,3,1,1),-p_(1,3,1,1)*p_(3,1,1,1)+p_(1,1,1,1)*p_(3,3,1,1),-p_(2,3,1,1)*p_(3,1,1,1)+p_(2,1,1,1)*p_(3,3,1,1),-p_(1,3,1,1)*p_(2,2,1,1)+p_(1,2,1,1)*p_(2,3,1,1),-p_(1,3,1,1)*p_(3,2,1,1)+p_(1,2,1,1)*p_(3,3,1,1),-p_(2,3,1,1)*p_(3,2,1,1)+p_(2,2,1,1)*p_(3,3,1,1),-p_(1,2,1,2)*p_(2,1,1,2)+p_(1,1,1,2)*p_(2,2,1,2),-p_(1,2,1,2)*p_(3,1,1,2)+p_(1,1,1,2)*p_(3,2,1,2),-p_(2,2,1,2)*p_(3,1,1,2)+p_(2,1,1,2)*p_(3,2,1,2),-p_(1,3,1,2)*p_(2,1,1,2)+p_(1,1,1,2)*p_(2,3,1,2),-p_(1,3,1,2)*p_(3,1,1,2)+p_(1,1,1,2)*p_(3,3,1,2),-p_(2,3,1,2)*p_(3,1,1,2)+p_(2,1,1,2)*p_(3,3,1,2),-p_(1,3,1,2)*p_(2,2,1,2)+p_(1,2,1,2)*p_(2,3,1,2),-p_(1,3,1,2)*p_(3,2,1,2)+p_(1,2,1,2)*p_(3,3,1,2),-p_(2,3,1,2)*p_(3,2,1,2)+p_(2,2,1,2)*p_(3,3,1,2),-p_(1,2,2,1)*p_(2,1,2,1)+p_(1,1,2,1)*p_(2,2,2,1),-p_(1,2,2,1)*p_(3,1,2,1)+p_(1,1,2,1)*p_(3,2,2,1),-p_(2,2,2,1)*p_(3,1,2,1)+p_(2,1,2,1)*p_(3,2,2,1),-p_(1,3,2,1)*p_(2,1,2,1)+p_(1,1,2,1)*p_(2,3,2,1),-p_(1,3,2,1)*p_(3,1,2,1)+p_(1,1,2,1)*p_(3,3,2,1),-p_(2,3,2,1)*p_(3,1,2,1)+p_(2,1,2,1)*p_(3,3,2,1),-p_(1,3,2,1)*p_(2,2,2,1)+p_(1,2,2,1)*p_(2,3,2,1),-p_(1,3,2,1)*p_(3,2,2,1)+p_(1,2,2,1)*p_(3,3,2,1),-p_(2,3,2,1)*p_(3,2,2,1)+p_(2,2,2,1)*p_(3,3,2,1),-p_(1,2,2,2)*p_(2,1,2,2)+p_(1,1,2,2)*p_(2,2,2,2),-p_(1,2,2,2)*p_(3,1,2,2)+p_(1,1,2,2)*p_(3,2,2,2),-p_(2,2,2,2)*p_(3,1,2,2)+p_(2,1,2,2)*p_(3,2,2,2),-p_(1,3,2,2)*p_(2,1,2,2)+p_(1,1,2,2)*p_(2,3,2,2),-p_(1,3,2,2)*p_(3,1,2,2)+p_(1,1,2,2)*p_(3,3,2,2),-p_(2,3,2,2)*p_(3,1,2,2)+p_(2,1,2,2)*p_(3,3,2,2),-p_(1,3,2,2)*p_(2,2,2,2)+p_(1,2,2,2)*p_(2,3,2,2),-p_(1,3,2,2)*p_(3,2,2,2)+p_(1,2,2,2)*p_(3,3,2,2),-p_(2,3,2,2)*p_(3,2,2,2)+p_(2,2,2,2)*p_(3,3,2,2),-p_(1,1,1,2)*p_(1,1,2,1)+p_(1,1,1,1)*p_(1,1,2,2),-p_(1,2,1,2)*p_(1,2,2,1)+p_(1,2,1,1)*p_(1,2,2,2),-p_(1,3,1,2)*p_(1,3,2,1)+p_(1,3,1,1)*p_(1,3,2,2),-p_(2,1,1,2)*p_(2,1,2,1)+p_(2,1,1,1)*p_(2,1,2,2),-p_(2,2,1,2)*p_(2,2,2,1)+p_(2,2,1,1)*p_(2,2,2,2),-p_(2,3,1,2)*p_(2,3,2,1)+p_(2,3,1,1)*p_(2,3,2,2),-p_(3,1,1,2)*p_(3,1,2,1)+p_(3,1,1,1)*p_(3,1,2,2),-p_(3,2,1,2)*p_(3,2,2,1)+p_(3,2,1,1)*p_(3,2,2,2),-p_(3,3,1,2)*p_(3,3,2,1)+p_(3,3,1,1)*p_(3,3,2,2));
     I
     );

-- Lets compute the GB of some ideal from algebraic statistics 100 times
R = markovRing (3,3,2,2)
S = {{{1},{2},{3,4}},{{3},{4},{1,2}}}
jobs = for t in 1..5 list markovIdeal(R,S);

timing1 = timing gb markovIdeal(R,S)
-- 1.5 seconds on my machine

--caveat: Can't use time for this one b/c it only measures 
--the time that the scheduling takes

start = currentTime();
pscan (jobs, gb); stop = currentTime();
timeTaken = stop-start

papply (jobs, gb); 
stop = currentTime();

--approximation in seconds
timeTaken = stop-start

--66 seconds on my machine, so approx 1.32 seconds per GB.
--There is an overhead!
