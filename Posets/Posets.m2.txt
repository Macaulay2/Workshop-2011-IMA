needsPackage"Posets"


-------------------------------------------------------------------------------------------------------------------------------------------------------------

--Finished
--Imput: Two posets
--Output: Product of posets
--How: Combine Grounds Set. Find cover relations by combining cover relations of P with ground set elements of Q remaining constant. 
--       Then mirror with Q and P exchanged.
posetProduct = method();
posetProduct (Poset,Poset) := (P,Q) -> 
	poset(flatten for p in P.GroundSet list for q in Q.GroundSet list {p, q},
	      join(flatten for c in P.Relations list for q in Q.GroundSet list ({c_0, q}, {c_1, q}),
		   flatten for c in Q.Relations list for p in P.GroundSet list ({p, c_0}, {p, c_1})));

-------------------------------------------------------------------------------------------------------------------------------------------------------------


--Finished
posetDiamondProduct = method();
posetDiamondProduct (Poset,Poset) := (P,Q)->(
	if isLattice P and isLattice Q then (
		P':=posetProduct(dropElements(P, minimalElements P),dropElements(Q, minimalElements Q));
		poset(prepend({symbol zeroHat}, P'.GroundSet), join(apply(minimalElements P', p->({symbol zeroHat},p)),P'.Relations))
	) else error "P and Q must be lattices"
);



-------------------------------------------------------------------------------------------------------------------------------------------------------------

isGraded = method();
isGraded (Poset) := P->(
	all(minimalElements P, z->all(P.GroundSet,p->if compare(P,z,p) then #unique apply(maximalChains closedInterval(P,z,p), c -> #c) == 1 else true))
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------

--Broke
gradePoset = method();
gradePoset (Poset) := P->(
	if not isGraded P then error"P must be graded";
	L:={};
	n:=max apply(maximalChains P, c->#c);
	M:=maximalChains P;
	for i to #M-1 do (
		if #M_i==n then {
			L=append(L,M_i)
		};
	);
	apply(max apply(L,c->#c), d -> unique for c in L list if c#?d then c#d else continue)
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------

--Finished
gradeLattice = method();
gradeLattice (Poset) := P->(
	--if not isGraded P then error"P must be graded";
	--if not isLattice P then error"P must be a Lattice";
	M:=maximalChains P;
	if #(unique apply(M,c->#c))!= 1 then error"P must be graded";
	apply(max apply(M,c->#c), d -> unique for c in M list if c#?d then c#d else continue)
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------


R=QQ[x_1..x_100];
P=poset({x_1,x_2,x_3,x_4},{(x_1,x_2),(x_1,x_3),(x_2,x_4),(x_3,x_4)})
Q=poset({x_5,x_6,x_7},{(x_5,x_6),(x_6,x_7)})