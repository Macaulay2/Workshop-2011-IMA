needsPackage("Posets", FileName=>"/home/math dept/workshops/IMA-2011/Posets/Posets.m2");
--needsPackage"Posets"


-------------------------------------------------------------------------------------------------------------------------------------------------------------

--Finished
distributiveLattice = method();
distributiveLattice (Poset):=P->(
	L:=apply(subsets(P.GroundSet),i->i);
	J:={};
	G:={{}};
	R:={};
	Q:={};
	for i to #L-1 do(
		if L_i != {} then{
		K:=apply(L_i, p->orderIdeal(P,p));
		for k to #K-1 do(
			if k == 0 then{
				Q=K_k;
			};
			Q=join(Q,K_k);
		);
		Q=unique flatten Q;
		J=append(J,Q);
		};
	);
	for i to #J-1 do(
		if not member(sort (J_i),G) then{
			G=append(G,sort (J_i));
		};
	);
	for i to #G-1 do(
		for j to #G-1 do(
			if j!=i then{	
				if #G_i== #G_j-1 then{
				if isSubset(G_i,G_j) then{
					R=append(R,(G_i,G_j));
				};
				};
			};
		);
	);
	POI:=poset(G,R);
	POI.cache.OriginalPoset=P;
	POI		
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------

--Needs Checking
--baseDistributiveLattice = method ();
--baseDistributiveLattice (Poset) := P->(
--	subPoset(P,meetIrreducibles(P))
--); 

-------------------------------------------------------------------------------------------------------------------------------------------------------------

--Finished
isConnected = method();
isConnected (Poset):= P->(
	J:=(maximalChains P)_0;
	counter:=1;
	answer=false;
	while counter != 0 do(
	counter=0;
	for i to #P.GroundSet-1 do(
		if not member(P.GroundSet_i,J) then{
		for j to #P.Relations-1 do(
			if P.GroundSet_i == P.Relations_j_0 and member(P.Relations_j_1,J) then{
				J=append(J,P.GroundSet_i); 
				counter = counter + 1;
			};
			if P.GroundSet_i == P.Relations_j_1 and member(P.Relations_j_0,J) then{
				J=append(J,P.GroundSet_i); 
				counter = counter + 1;
			};
		);
		};
	);
	);
	J=unique J;
	if #J == #P.GroundSet then{
			answer=true; 	
	};
	answer
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------

--Finished
isDistributive = method();
isDistributive (Poset) := P->(
	if not isLattice P then error "Poset must be a lattice";
	J:=subsets(P.GroundSet);
	G:={};
	answer:=true;
	for i to #J-1 do(
		if #J_i == 3 then{
			G=append(G,J_i);
		};
	);
	for i to #G-1 do(
		if answer!=false then{
			if posetMeet(P,G_i_0,first posetJoin(P,G_i_1,G_i_2))!=posetJoin(P,first posetMeet(P,G_i_0,G_i_1),first posetMeet(P,G_i_0,G_i_2)) then{
				answer=false;
			};
		};
	);
	answer
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------


--Note: Poset must be properly labeled. Ground Set should look like {grade level, numerical label, monomial label}
--Signs not implemented
cellularResolution = method();
cellularResolution (Poset):= P->(
	J:=P.Relations;
	n:=max apply(maximalChains P,c->#c);
	G:=toList(n:toList({}));
	Maps:={};
	for j to n-1 do(
		for i to #P.GroundSet-1 do(
			if P.GroundSet_i_0 == j then{
				G=replace(j,append(G_j,P.GroundSet_i),G);
			};
		);
	);
	for i to #G-2 do(
		M:=toList(#G_i:toList(#G_(i+1):0));
		for j to #G_i-1 do(
			for k to #G_(i+1)-1 do(
				if member((G_i_j,G_(i+1)_k),P.Relations) then{
					M=replace(j,replace(k,G_(i+1)_k_2/G_i_j_2,M_j),M);
				};
			);
		);
		Maps=append(Maps,M);
	);
	Maps
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------

--Finished
antichains = method();
antichains (Poset) := P->(
	L:=subsets(P.GroundSet);
	G:={};
	for i to #L-1 do(
		if isAntichain(P,L_i) then G=append(G,L_i);
	);
	G
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------

flagPoset = method();
flagPoset (Poset,List) := (P,L)->(
	G:=gradePoset(P);
	Q:={};
	for i to #L-1 do(
		Q=append(Q,G_(L_i));
	);
	subPoset(P,flatten Q)
);

flagChains = method();
flagChains (Poset,List):= (P,L)->(
	maximalChains(flagPoset(P,L))
);

fvector = method();
fvector (Poset) := P->(
	G:=gradePoset(P);
	v:={};
	for i to #G-1 do(
		v=append(v,#G_i);
	);
	v
);
-------------------------------------------------------------------------------------------------------------------------------------------------------------


R=QQ[x_1..x_100];
P=poset({x_1,x_2,x_3,x_4},{(x_1,x_2),(x_1,x_3),(x_2,x_4),(x_3,x_4)});
Q=poset({x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8},{(x_1,x_2),(x_1,x_3),(x_2,x_4),(x_3,x_4),(x_5,x_6),(x_6,x_8),(x_7,x_8)});
L=poset({x_5,x_6,x_7,x_8},{(x_5,x_6),(x_6,x_8),(x_7,x_8)});
H={{0,0,x_1*x_3},{0,1,x_1*x_4},{0,2,x_1*x_5},{0,3,x_2*x_4},{0,4,x_2*x_5},{0,5,x_3*x_5},{1,0,x_1*x_3*x_5},{1,1,x_1*x_3*x_4},{1,2,x_1*x_3*x_5},{1,3,x_2*x_3*x_5},{1,4,x_1*x_4*x_5},{1,5,x_1*x_2*x_5},{1,6,x_2*x_4*x_5},{1,7,x_1*x_2*x_4},{2,0,x_1*x_3*x_4*x_5},{2,1,x_1*x_2*x_4*x_5},{2,2,x_1*x_2*x_3*x_5}};
bigH = H->(
	R:={};
	for i to #H-1 do(
		for j to #H-1 do(
			if H_i_0==H_j_0-1 and gcd(H_i_2,H_j_2)==H_i_2 then{
				R=append(R,(H_i,H_j));
			};
		);
	);
	poset(H,R)
);

--H=poset({{0,0,x_1*x_3},{0,1,x_1*x_4},{0,2,x_1*x_5},{1,0,x_1*x_3*x_5},{1,1,x_1*x_3*x_4},{1,2,x_1*x_4*x_5},{2,0,x_1*x_3*x_4*x_5}},{({0,0,x_1*x_3},{1,0,x_1*x_3*x_5}),({0,0,x_1*x_3},{1,1,x_1*x_3*x_4}),({0,1,x_1*x_4},{1,1,x_1*x_3*x_4}),({0,1,x_1*x_4},{1,2,x_1*x_4*x_5}),({0,2,x_1*x_5},{1,2,x_1*x_4*x_5}),({0,2,x_1*x_5},{1,0,x_1*x_3*x_5}),({1,1,x_1*x_3*x_4},{2,0,x_1*x_3*x_4*x_5}),({1,0,x_1*x_3*x_5},{2,0,x_1*x_3*x_4*x_5}),({1,2,x_1*x_4*x_5},{2,0,x_1*x_3*x_4*x_5})});