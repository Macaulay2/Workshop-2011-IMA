newPackage("Tropical",
     Headline => "A package for tropical geometry",
     Version => "0.1",
     Date => "July 26, 2011",
     Authors => {
	  {Name => "Josephine Yu",
	   HomePage => "http://people.math.gatech.edu/~jyu67",
	   Email => "josephine.yu@math.gatech.edu"}},
      DebuggingMode => true
      )
 
export {
     --objects
      TropicalVariety,
      --methods
      tropicalVariety,
      tropicalMap,
      tropicalDiscriminant,
      tropicalResultant,
      cayleySum
      --options
      }
 
needsPackage "gfanInterface2"
-- needsPackage "Polyhedra"
-- needsPackage "Polymake"

-----------------------------------------------
-- OBJECTS
-----------------------------------------------

TropicalVariety = new Type of PolymakeObject;

-----------------------------------------------
-- CONSTRUCTOR
----------------------------------------------

tropicalVariety = method( Options => {
	"stable" => false, 
	"symmetry" => null, 
	"disableSymmetryTest" => false})
tropicalVariety List := opts -> L -> (
  	  gfanTropicalTraverse(gfanTropicalStartingCone(L,"stable" => opts#"stable"), opts)     
     )
tropicalVariety Ideal := opts -> I -> (
     tropicalVariety(I_*, opts)
     )

-----------------------------------------------
-- FUNCTIONS
-----------------------------------------------


----------------local functions-------------------------------

----------------------------
-- normalize
----------------------------
normalize := A -> (
     A/(a-> (g := gcd a; apply(a,i->i//g))
	  )
     )

----------------------------
-- latticeIndex
----------------------------
-- INPUT: a matrix A
-- OUTPUT: index of the lattice generated by rows on A, inside the integer lattice
-- 	   returns 0 if the index is not finite
latticeIndex := A -> (
     det smithNormalForm(A,ChangeMatrix=>{false,false})
     )

----------------------------
-- extrinsicIndex
----------------------------
-- INPUT: a cone C given by a list of generators (lists)
--     	  and a matrix A respresenting a linear map
-- OUTPUT: extrinsic multiplicity of the image cone
--     	   computed as the index of the image lattice in the integer lattice
--     	   a la Sturmfels--Tevelev
extrinsicIndex := (C,A) -> (
     latticeBasis := transpose gens kernel transpose gens kernel matrix C;
     latticeIndex (latticeBasis * transpose A)	  
     )


----------------------------
-- cayleySum
----------------------------
-- INPUT: a list of matrices, all with the same number of rows
-- OUTPUT: a matrix, representing the Cayley sum of the columns of input matrices
cayleySum = method()
cayleySum List := L -> (
     if (not # set(L / numRows) == 1) then
     	  error "the matrices in the list must have the same number of rows";
     N := L / numColumns;
     matrix( flatten \ table(#N, #N, (i,j) -> (
	       if(not i == j) then (
	       	    toList (1..N#j)/(k->0)
		    ) else (
		    toList (1..N#j)/(k->1)	       	 
		    )
	       ))) || fold((a,b)->a|b, L)
     )


---------------exported functions--------------------------------

----------------------------
--- tropicalMap
----------------------------
tropicalMap = method()
tropicalMap (PolymakeObject, Matrix) := (T,A) -> (
     if not(numColumns A == T#"AMBIENT_DIM") then
     	  error "The number of columns of the matrix must equal the ambient dimension of the fan";
     H := {"AMBIENT_DIM" => numRows A};
     lineality := transpose gens gb sub(A*transpose matrix T#"LINEALITY_SPACE", QQ);
     H = H| {"LINEALITY_DIM" => numRows lineality, "LINEALITY_SPACE" => entries lineality, "ORTH_LINEALITY" => entries transpose gens kernel lineality} ;
     imageRays := normalize entries transpose(A*transpose matrix(T#"RAYS")) ;  
     numMaxCones := #T#"MAXIMAL_CONES";  
     imageConeIndices := partition(j -> rank ((matrix apply(T#"MAXIMAL_CONES"#j, i -> imageRays#i))||lineality),0..numMaxCones-1);
     newDim := max keys imageConeIndices;
     goodConeIndices := toList imageConeIndices#(newDim); 
     goodRayIndices := select(#imageRays, i -> not (rank ((matrix{imageRays#i}) || lineality) == numRows lineality));
     oldMultList := T#"MULTIPLICITIES";
     multList := apply(goodConeIndices, i -> (
	 C := T#"MAXIMAL_CONES"#i;
    	 intrinMult := oldMultList#i;
     	 extrinMult := extrinsicIndex(C /(j -> T#"RAYS"#j) | T#"LINEALITY_SPACE", A);
	 intrinMult * extrinMult	 
	       ));
     H = H | {"DIM" => newDim, "RAYS" => apply(goodRayIndices, i-> imageRays#i), "MAXIMAL_CONES" => apply(goodConeIndices, C -> select(apply(T#"MAXIMAL_CONES"#C, i-> position(goodRayIndices, j -> j == i)), c -> not c === null)), "MULTIPLICITIES" => multList};
     new TropicalVariety from hashTable H
     )


----------------------------
--- tropicalDiscriminant
----------------------------
--INPUT: a matrix, whose columns form a vector configuration A
--OUTPUT:  tropical A-discriminant (GKZ, Dickenstein-Feichter-Sturmfels)
tropicalDiscriminant = method()
tropicalDiscriminant Matrix := A -> (
     n := numColumns A;
     x := local x;
     R := QQ(monoid[x_0..x_(n-1)]);
     I := ideal( (entries A) / (a -> sum apply(toList(0..#a-1), i -> a#i*R_i)));
     T := gfanTropicalVariety I;
     B := transpose gens kernel A;
     tropicalMap(T,transpose gens kernel A)
     )


----------------------------
--- tropicalResultant
----------------------------
--INPUT: a list of matrices, representing point configurations
--OUTPUT: tropical resultant

tropicalResultant = method()
tropicalResultant List := L -> (
     if (not # set(L / numRows) == 1) then
     	  error "the matrices in the list must have the same number of rows";
     numVars := numRows (L#0);
     gfanInput := 
     )
     
{*
tropicalResultant = method()
tropicalResultant List := L -> (
     if (not # set(L / numRows) == 1) then
     	  error "the matrices in the list must have the same number of rows";
     N := L / numColumns;
     ambientDim := sum N;
     rays := entries id_(ZZ^ambientDim);
     chosenMixedCells := fold( (a,b) -> toList(set(a)**set(b)), N / (n -> subsets(n,2)))/deepSplice;
     count := 0;
     startIndices := for n in N list count do count=count+n;
     mixedOrthants := apply(chosenMixedCells, C -> (
	      flatten apply(#C, i -> sort( (toList(set(0..N#i-1)-C#i)) / (j->j+startIndices#i) ))
	  ));
     cayleySum L;
     -- NOT DONE!
     )
*}

----------------------------
--- secondaryFan
----------------------------
--INPUT: a matrix, whose columns form a vector configuration A
--OUTPUT:  



----------------------------
--- fiberFan
----------------------------



----------------------------
--- mixedFiberFan
----------------------------


----------------------------
--- TrIm
----------------------------



--------------------------------------------------------
-- Documentation
--------------------------------------------------------

beginDocumentation()

doc ///
	Key
		tropicalVariety
		(tropicalVariety, List)
		(tropicalVariety, Ideal)
		[tropicalVariety, "stable", "symmetry", "g", "d"]
	Headline
		Compute the tropical variety 
	Usage
		T = tropicalVariety(L)
		T = tropicalVariety(I)
	Inputs
		L:List
			containing polynomials generating an ideal homogeneous with respect to a positive grading
		I:Ideal
		        homogeneous with respect to a positive grading
	Outputs
		T:TropicalVariety
	Description
		Text
		       The optional input "stable" is for tropical stable intersections
		Example
			QQ[x,y,z];
///

end

-------------------------------------------------------------
-------------------------------------------------------------

restart
--loadPackage "gfanInterface"
installPackage ("gfanInterface2", FileName => "/Users/bb/Documents/math/M2codes/IMA-2011/gfanInterface2.m2", MakeDocumentation => true)
installPackage ("Polymake", FileName => "/Users/bb/Documents/math/M2codes/IMA-2011/Polymake.m2", MakeDocumentation => true)
installPackage ("Tropical", FileName => "/Users/bb/Documents/math/M2codes/IMA-2011/Tropical.m2")

loadPackage ("gfanInterface2", FileName => "/Users/bb/Documents/math/M2codes/IMA-2011/gfanInterface2.m2")
loadPackage ("Tropical", FileName => "/Users/bb/Documents/math/M2codes/IMA-2011/Tropical.m2", Reload => true)

needsPackage ("gfanInterface2", FileName => "/Users/bb/Documents/math/M2codes/IMA-2011/gfanInterface2.m2",  DebuggingMode =>true)
needsPackage("Tropical", FileName => "/Users/bb/Documents/math/M2codes/IMA-2011/Tropical.m2")

debug gfanInterface2
viewHelp gfanInterface2

viewHelp "gfanInterface2"
viewHelp "Polymake"
viewHelp "Tropical"

A = matrix {{1,1,1,1,1,1,1,1},{1,1,1,1,0,0,0,0},{1,1,0,0,1,1,0,0},{1,0,1,0,1,0,1,0}}
T = tropicalDiscriminant A

L = {random(ZZ^2,ZZ^3),random(ZZ^2,ZZ^3),random(ZZ^2,ZZ^3)}
cayleySum L

P = gfanTropicalStartingCone {x+y+z}
F = gfanTropicalTraverse P
F#D

QQ[z,h,x,y, MonomialOrder => Eliminate 2 ]
I = ideal{1+x+y, x^2-x+y^3-z^4}
J = homogenize(I,h)
T = tropicalVariety J
toPolymakeFormat T
A = matrix{{1, 0, 0, 0}, {0, 1, 0,0 }}
tropicalMap(T,A)
eliminate({z,h},J)
gens J

gfanVerbose = true
QQ[x,y,z,w,h]
I = ideal{x+y+z+w, (x+y+z+w)^2}
J = homogenize(I,h)
dim J
T = gfanTropicalVariety J
Tstable = gfanTropicalVariety(J_*, "stable" => true)
A = matrix{{1, 0, 0, -1, 0},{1,2,3,0,0},{0,2,3,4,5}}
tropicalMap(T,A)
tropicalMap(Tstable, A)

I = ideal{x+y+z, y^2+2*z^2+3*w^2+1}
J = homogenize(I,h)
T = tropicalVariety J
A = matrix{{0, -1, 0, 1, 0}, {0, 1, 0, 0, -1}, {0, 0, 1, 0, -1}}

A = matrix{{0, -1, 0, 1, 0}, {0, 1, 0, 0, -1}, {0, 0, 1, 0, -1},{0,0,0,1,-1}}
B = matrix{{1,1,1,1},{0,1,1,0},{0,0,-1,1},{0,0,0,2}}
hermite B
smithNormalForm B
gens (ZZ^4/image(B))

tropicalMap(T,A)
T
A = matrix{{1,2,3},{1,34,45},{2213,1123,6543},{0,0,0}}
rank A

toPolymakeFormat(T)
viewHelp toPolymakeFormat
viewHelp SRdeformations


----- Making non-acyclic vector configurations for experimentation with secondary fans

needsPackage "Polyhedra"

d=4;n=8;
(select( apply(1..100, a-> unique(
		    ((entries map(ZZ^d))/toSequence) | 
		    apply(toList(1..n-d), i->(apply(1..d, j -> random(-4,4))))/(l->(l/(a->a//gcd(l)))) 
		    ) 
       	       ), L -> (print L; C = posHull transpose matrix(L/toList); C#"dimension of lineality space" == d)   
	  )
     )/print
