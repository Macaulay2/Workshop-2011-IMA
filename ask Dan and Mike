
+ /Users/dan/src/M2/trunk/M2/BUILD/dan/builds.tmp/mac64.production/StagingArea/x86_64-MacOS-10.7/bin/M2 --no-readline --print-width 97
Macaulay2, version 1.4.0.1
with packages: ConwayPolynomials, Elimination, IntegralClosure, LLLBases, PrimaryDecomposition,
               ReesAlgebra, TangentCone

i1 : viewHelp

i2 : f = method()

o2 = f

o2 : MethodFunction

i3 : f List := print

o3 = print

o3 : FunctionClosure

i4 : f HashTable := print

o4 = print

o4 : FunctionClosure

i5 : f {}
{}

i6 : f List
List

i7 : f 4
stdio:7:1:(3): error: no method found for applying f to:
     argument   :  4 (of class ZZ)

i8 : X = new Type of List

o8 = X

o8 : Type

i9 : f X := x -> ( << "X: " << x << endl ; )

o9 = {*Function[stdio:9:10-9:32]*}

o9 : FunctionClosure

i10 : methods f

o10 = {(f, HashTable)}
      {(f, List)     }
      {(f, X)        }

o10 : VerticalList

i11 : f {}
{}

i12 : f (new X from {a,b,c} )
X: {a, b, c}

i13 : x = new X from {a,b,c}

o13 = {a, b, c}

o13 : X

i14 : toList x

o14 = {a, b, c}

o14 : List

i15 : new List from x

o15 = {a, b, c}

o15 : List

i16 : Y = new Type of X

o16 = Y

o16 : Type

i17 : y = new Y from {r,s,t}

o17 = {r, s, t}

o17 : Y

i18 : new X from y

o18 = {r, s, t}

o18 : X

i19 : toExternalString X := x -> concatenate ( "new X from ", toString toList x)

o19 = {*Function[stdio:19:25-19:73]*}

o19 : FunctionClosure

i20 : toExternalString x

o20 = new X from {a, b, c}

i21 : value oo

o21 = {a, b, c}

o21 : X

i22 : generateAssertions " toExternalString x "

o22 = 
      assert( ( toExternalString x ) === "new X from {a, b, c}" )

i23 : generateAssertions " 2+2 "

o23 = 
      assert( ( 2+2 ) === 4 )

i24 : x

o24 = {a, b, c}

o24 : X

i25 : net X := x -> toString x || toString x

o25 = {*Function[stdio:25:12-25:38]*}

o25 : FunctionClosure

i26 : x

o26 = X{a, b, c}
      X{a, b, c}

o26 : X

i27 : print x
X{a, b, c}
X{a, b, c}

i28 : QQ[a]

o28 = QQ[a]

o28 : PolynomialRing

i29 : print (a^2)
 2
a

i30 : toString x

o30 = X{a, b, c}

i31 : toExternalString x

o31 = new X from {a, b, c}

i32 : I = ideal a

o32 = ideal(a)

o32 : Ideal of QQ[a]

i33 : J = ideal a

o33 = ideal(a)

o33 : Ideal of QQ[a]

i34 : I === J

o34 = true

i35 : J = ideal (a,a^2)

                 2
o35 = ideal (a, a )

o35 : Ideal of QQ[a]

i36 : I === J

o36 = false

i37 : I == J

o37 = true

i38 : K = ideal (a^2,a)

              2
o38 = ideal (a , a)

o38 : Ideal of QQ[a]

i39 : J === K

o39 = false

i40 : J == K

o40 = true

i41 : X === X := (x,y) -> true
stdio:41:9:(3): error: can't assign a method for this binary operator

i42 : x

o42 = X{a, b, c}
      X{a, b, c}

o42 : X

i43 : {a,b,c} === {a,b,c}

o43 = true

i44 : (new X from {a,b,c}) === (new X from {a,b,c})

o44 = true

i45 : (new X from {a,b,c}) == (new X from {a,b,c})

o45 = true

i46 : (new X from {a,b,c}) == (new X from {b,a,c})
stdio:46:22:(3): error: no method for binary operator == applied to objects:
--            a (of class QQ[a])
--     ==     b (of class Symbol)

i47 : X == X := (x,y) -> true

o47 = {*Function[stdio:47:17-47:20]*}

o47 : FunctionClosure

i48 : (new X from {a,b,c}) == (new X from {b,a,c})

o48 = true

i49 : debug Core

i50 : apropos "^raw"

o50 = {raw, rawAlexanderDual, rawAmbientRing, rawAssociateDivisor, rawBasis, rawBetti,
      -------------------------------------------------------------------------------------------
      rawBettiTally, rawBIBasis, rawCC, rawCharSeries, rawClean, rawCodimension, rawCoefficient,
      -------------------------------------------------------------------------------------------
      rawCoefficients, rawColon, rawColumnDotProduct, rawCompare, rawCompareMonomial, rawConcat,
      -------------------------------------------------------------------------------------------
      rawConcatBlocks, rawConcatColumns, rawConcatRows, rawContent, rawConvolve, rawDeclareField,
      -------------------------------------------------------------------------------------------
      rawDegree, rawDeleteColumns, rawDeleteRows, rawDenominator, rawDenominatorRing, rawDiff,
      -------------------------------------------------------------------------------------------
      rawDirectSum, rawDiscreteLog, rawDivideByVariable, rawDivMod, rawDual, rawDummy,
      -------------------------------------------------------------------------------------------
      rawEigenvalues, rawEigenvectors, rawEliminateVariables, rawEvaluateSLP, rawExtendedGCD,
      -------------------------------------------------------------------------------------------
      rawExtensionDegree, rawExteriorPower, rawExtract, rawExtractColumns, rawFactor, rawFFLU,
      -------------------------------------------------------------------------------------------
      rawFFPackAddMultipleTo, rawFFPackColumnRankProfile, rawFFPackDeterminant, rawFFPackInvert,
      -------------------------------------------------------------------------------------------
      rawFFPackNullSpace, rawFFPackRank, rawFFPackRowRankProfile, rawFFPackSolve, rawFlip,
      -------------------------------------------------------------------------------------------
      rawFraction, rawFractionRing, rawFreeModule, rawFromNumber, rawGaloisField, rawGB,
      -------------------------------------------------------------------------------------------
      rawGBBetti, rawGbBoolean, rawGBChangeOfBasis, rawGBContains, rawGBForce, rawGBGetLeadTerms,
      -------------------------------------------------------------------------------------------
      rawGBGetMatrix, rawGBGetParallelLeadTerms, rawGBMatrixLift, rawGBMatrixRemainder,
      -------------------------------------------------------------------------------------------
      rawGBMinimalGenerators, rawGBSetHilbertFunction, rawGBSetStop, rawGBSyzygies, rawGCD,
      -------------------------------------------------------------------------------------------
      rawGetAllSolutionsPT, rawGetMatrixEntry, rawGetNonUnit, rawGetPart, rawGetParts,
      -------------------------------------------------------------------------------------------
      rawGetSchreyer, rawGetSolutionLastTvaluePT, rawGetSolutionPT, rawGetSolutionRcondPT,
      -------------------------------------------------------------------------------------------
      rawGetSolutionStatusPT, rawGetSolutionStepsPT, rawGetSubmatrix, rawGetTerms,
      -------------------------------------------------------------------------------------------
      rawHermiteNormalForm, rawHilbert, rawHomogenize, rawIdealReorder, rawIdentity,
      -------------------------------------------------------------------------------------------
      rawIndexIfVariable, rawIndices, rawInitial, rawInsertColumns, rawInsertRows, rawIntersect,
      -------------------------------------------------------------------------------------------
      rawInverse, rawIsDense, rawIsEqual, rawIsField, rawIsHomogeneous, rawIsStronglyStable,
      -------------------------------------------------------------------------------------------
      rawIsZero, rawKeepVariables, rawKernelOfGB, rawKoszul, rawKoszulMonomials, rawLaunchPT,
      -------------------------------------------------------------------------------------------
      rawLCM, rawLeadCoefficient, rawLeadMonomial, rawLeadMonomialR, rawLeastSquares, rawLift,
      -------------------------------------------------------------------------------------------
      rawLLL, rawLocalRing, rawLowerP, rawLU, rawMakeMonomial, rawMarkedGB, rawMatrix,
      -------------------------------------------------------------------------------------------
      rawMatrix1, rawMatrix2, rawMatrixColumnChange, rawMatrixColumnOperation2,
      -------------------------------------------------------------------------------------------
      rawMatrixColumnScale, rawMatrixColumnSwap, rawMatrixCompress, rawMatrixContract,
      -------------------------------------------------------------------------------------------
      rawMatrixDiff, rawMatrixEntry, rawMatrixRemake1, rawMatrixRemake2, rawMatrixRowChange,
      -------------------------------------------------------------------------------------------
      rawMatrixRowOperation2, rawMatrixRowScale, rawMatrixRowSwap, rawMaximalIndependentSets,
      -------------------------------------------------------------------------------------------
      rawMemoryUsageStatus, rawMinors, rawModuleTensor, rawMonoid, rawMonomialDivide,
      -------------------------------------------------------------------------------------------
      rawMonomialDivides, rawMonomialIdeal, rawMonomialIdealLCM, rawMonomialIdealToMatrix,
      -------------------------------------------------------------------------------------------
      rawMonomialMinimalPrimes, rawMonomialOrdering, rawMonomials, rawMultiDegree,
      -------------------------------------------------------------------------------------------
      rawMutableIdentity, rawMutableMatrix, rawMutableMatrixFillRandom,
      -------------------------------------------------------------------------------------------
      rawMutableMatrixFillRandomDensity, rawNorm, rawNullspaceU, rawNumberOfColumns,
      -------------------------------------------------------------------------------------------
      rawNumberOfInvertibleVariables, rawNumberOfRows, rawNumberOfVariables, rawNumerator,
      -------------------------------------------------------------------------------------------
      rawNumgens, rawPairs, rawPathTracker, rawPathTrackerPrecookedSLPs,
      -------------------------------------------------------------------------------------------
      rawPathTrackerProjective, rawPermuteColumns, rawPermuteRows, rawPfaffians,
      -------------------------------------------------------------------------------------------
      rawPolynomialRing, rawPowerMod, rawProductMonomialOrdering, rawPromote, rawPseudoRemainder,
      -------------------------------------------------------------------------------------------
      rawQQ, rawQuotientRing, rawRadical, rawRandomCC, rawRandomConstantMatrix,
      -------------------------------------------------------------------------------------------
      rawRandomInitialize, rawRandomQQ, rawRandomRR, rawRandomZZ, rawRank, rawReduceByPivots,
      -------------------------------------------------------------------------------------------
      rawRefinePT, rawRemoveContent, rawRemoveMonomialFactors, rawRemoveScalarMultiples,
      -------------------------------------------------------------------------------------------
      rawReshape, rawResolution, rawResolutionGetFree, rawResolutionGetMatrix,
      -------------------------------------------------------------------------------------------
      rawResolutionStatusLevel, rawRing, rawRingMap, rawRingMapEval, rawRingVar, rawRR,
      -------------------------------------------------------------------------------------------
      rawSaturate, rawSchreyerSource, rawSchurDimension, rawSchurFromPartition, rawSchurRing,
      -------------------------------------------------------------------------------------------
      rawSchurRing1, rawSchurSnRing, rawSchurSnTensorMult, rawSetDegree, rawSetMatrixEntry,
      -------------------------------------------------------------------------------------------
      rawSetMatrixValues, rawSetParametersPT, rawShowComputation, rawSkewPolynomialRing, rawSLP,
      -------------------------------------------------------------------------------------------
      rawSmithNormalForm, rawSolvableAlgebra, rawSolve, rawSortColumns, rawSortColumns2,
      -------------------------------------------------------------------------------------------
      rawSource, rawSparseListFormMonomial, rawSparseMatrix1, rawSparseMatrix2, rawSplitContent,
      -------------------------------------------------------------------------------------------
      rawStartComputation, rawStatus1, rawStatus2, rawStatusResolution, rawStronglyStableClosure,
      -------------------------------------------------------------------------------------------
      rawSubduction, rawSubmatrix, rawSubmodule, rawSVD, rawSymmetricPower, rawSyzygy, rawTarget,
      -------------------------------------------------------------------------------------------
      rawTensor, rawTerm, rawTermCount, rawToCC, rawToInteger, rawTopCoefficients, rawToRational,
      -------------------------------------------------------------------------------------------
      rawToRR, rawTowerQuotientRing, rawTowerRing, rawTowerRingAdjoinVariables,
      -------------------------------------------------------------------------------------------
      rawTowerTranslatePoly, rawVarMonomial, rawWedgeProduct, rawWeightRange, rawWeylAlgebra,
      -------------------------------------------------------------------------------------------
      rawZero, rawZZ, rawZZp}

o50 : List

i51 : X RingElement := print

o51 = print

o51 : FunctionClosure

i52 : x a
(X{a, b, c}, a)
 X{a, b, c}

i53 : methods symbol SPACE

o53 = {((SPACE, =), Function, Thing)             }
      {((SPACE, =), Thing, Thing)                }
      {((SPACE, =), Type, Type)                  }
      {(SPACE, BettiTally, Array)                }
      {(SPACE, BettiTally, ZZ)                   }
      {(SPACE, ChainComplex, Array)              }
      {(SPACE, ChainComplexMap, Array)           }
      {(SPACE, CoherentSheaf, LowerBound)        }
      {(SPACE, CoherentSheaf, ZZ)                }
      {(SPACE, Command, Thing)                   }
      {(SPACE, Expression, Expression)           }
      {(SPACE, Expression, Holder)               }
      {(SPACE, Expression, Thing)                }
      {(SPACE, Function, Thing)                  }
      {(SPACE, GradedModule, Array)              }
      {(SPACE, HeaderType, List)                 }
      {(SPACE, HeaderType, Sequence)             }
      {(SPACE, Holder, Expression)               }
      {(SPACE, Holder, Holder)                   }
      {(SPACE, InexactFieldFamily, Array)        }
      {(SPACE, InexactFieldFamily, OrderedMonoid)}
      {(SPACE, Manipulator, Database)            }
      {(SPACE, Manipulator, File)                }
      {(SPACE, Manipulator, NetFile)             }
      {(SPACE, Manipulator, Nothing)             }
      {(SPACE, MarkUpType, Hypertext)            }
      {(SPACE, MarkUpType, Net)                  }
      {(SPACE, MarkUpType, String)               }
      {(SPACE, Matrix, Vector)                   }
      {(SPACE, Module, Array)                    }
      {(SPACE, ProjectiveHilbertPolynomial, ZZ)  }
      {(SPACE, Ring, Array)                      }
      {(SPACE, Ring, List)                       }
      {(SPACE, Ring, OrderedMonoid)              }
      {(SPACE, RingElement, Array)               }
      {(SPACE, RingMap, ChainComplex)            }
      {(SPACE, RingMap, ChainComplexMap)         }
      {(SPACE, RingMap, Ideal)                   }
      {(SPACE, RingMap, Matrix)                  }
      {(SPACE, RingMap, Module)                  }
      {(SPACE, RingMap, Number)                  }
      {(SPACE, RingMap, RingElement)             }
      {(SPACE, RingMap, Vector)                  }
      {(SPACE, ScriptedFunctor, Thing)           }
      {(SPACE, SelfInitializingType, Thing)      }
      {(SPACE, SheafOfRings, LowerBound)         }
      {(SPACE, SheafOfRings, ZZ)                 }
      {(SPACE, Thing, Expression)                }
      {(SPACE, Thing, Thing)                     }
      {(SPACE, WrapperType, List)                }
      {(SPACE, WrapperType, Sequence)            }
      {(SPACE, WrapperType, Thing)               }
      {(SPACE, X, RingElement)                   }

o53 : VerticalList

i54 : betti res coker vars ring a

             0 1
o54 = total: 1 1
          0: 1 1

o54 : BettiTally

i55 : oo[4]

             -4 -3
o55 = total:  1  1
          4:  1  1

o55 : BettiTally

i56 : 5 t
stdio:56:1:(3): error: no method for adjacent objects:
--            5 (of class ZZ)
--    SPACE   t (of class Symbol)

i57 : code methods symbol SPACE

o57 = -- code for method: Function SPACE Thing = Thing
      ../trunk/M2/Macaulay2/m2/methods.m2:571:26-573:21: --source code:
      Function Thing = (f,x,e) -> (
           if not storefuns#?f then error("no method for storing values of function ", toString f);
           storefuns#f (x,e))
      ---------------------------------
      -- code for method: Thing SPACE Thing = Thing
      ../trunk/M2/Macaulay2/m2/robust.m2:69:67-83:85: --source code:
                     installMethod((op,symbol =), Thing, Thing, (x,y,z) -> (
                               preY := centerString(width preX, opstring);
                               preZ := centerString(width preX, "=");
                               line1 := concatenate("no method for assignment to ",
                                    if op === symbol SPACE then "adjacent objects:" else concatenate("binary operator ",op," applied to objects:")
                                    );
                               if hush then error(line1, " not displayed");
                               wid := max(printWidth,80);                                 -- error might occur while printWidth is narrowed
                               wid = wid - commentGuardWidth - width preX;
                               hush = true;                                       -- prevent error message recursion
                               line2 := preX | silentRobustNetWithClass(wid,ht,errorPrintingTimeLimit,x);
                               line3 := preY | silentRobustNetWithClass(wid,ht,errorPrintingTimeLimit,y);
                               {* line4 := preZ | silentRobustNetWithClass(wid,ht,errorPrintingTimeLimit,z); *}
                               hush = false;
                               error toString stack(line1,commentGuard line2,commentGuard line3{*,commentGuard line4*}))));
      | symbol     class      value          location of symbol
      | ------     -----      -----          ------------------                            
      | op       : Keyword -- SPACE          ../trunk/M2/Macaulay2/m2/robust.m2:63:31-63:33
      | opstring : String  -- "SPACE"        ../trunk/M2/Macaulay2/m2/robust.m2:64:11-64:19
      | ht       : ZZ      -- 8              ../trunk/M2/Macaulay2/m2/robust.m2:65:11-65:13
      | preX     : String  -- "            " ../trunk/M2/Macaulay2/m2/robust.m2:66:11-66:15
      ---------------------------------
      -- code for method: Type SPACE Type = Thing
      ../trunk/M2/Macaulay2/m2/methods.m2:452:60-452:97: --source code:
                installAssignmentMethod(op, Type, Type, (X,Y,am) -> installAssignmentMethod(op, X, Y, am));
      | symbol   class      value location of symbol
      | ------   -----      ----- ------------------                               
      | op     : Keyword -- SPACE ../trunk/M2/Macaulay2/m2/methods.m2:451:31-451:33
      ---------------------------------
      -- code for method: BettiTally Array
      ../trunk/M2/Macaulay2/m2/chaincomplexes.m2:657:27-660:37: --source code:
      BettiTally Array := (C,A) -> (
            if # A =!= 1 then error "expected array of length 1";
            n := A#0;
            applyKeys(C,(i,d,h) -> (i-n,d,h)))
      ---------------------------------
      -- code for method: BettiTally ZZ
      ../trunk/M2/Macaulay2/m2/chaincomplexes.m2:652:24-652:58: --source code:
      BettiTally ZZ := (C,n) -> applyKeys(C, (i,d,h) -> (i,d,h-n))
      ---------------------------------
      -- code for method: ChainComplex Array
      ../trunk/M2/Macaulay2/m2/chaincomplexes.m2:557:45-570:6: --source code:
      ChainComplex Array := ChainComplex => (C,A) -> (
           if # A =!= 1 then error "expected array of length 1";
           n := A#0;
           if not instance(n,ZZ) then error "expected an integer";
           D := new ChainComplex;
           b := D.dd;
           D.ring = ring C;
           complete C;
           scan(pairs C,(i,F) -> if class i === ZZ then D#(i-n) = F);
           complete C.dd;
           if even n
           then scan(pairs C.dd, (i,f) -> if class i === ZZ then b#(i-n) = f)
           else scan(pairs C.dd, (i,f) -> if class i === ZZ then b#(i-n) = -f);
           D)
      ---------------------------------
      -- code for method: ChainComplexMap Array
      ../trunk/M2/Macaulay2/m2/chaincomplexes.m2:572:51-583:6: --source code:
      ChainComplexMap Array := ChainComplexMap => (f,A) -> (
           if # A =!= 1 then error "expected array of length 1";
           n := A#0;
           if not instance(n,ZZ) then error "expected an integer";
           complete f;
           g := new ChainComplexMap;
           g.cache = new CacheTable;
           g.source = f.source A;
           g.target = f.target A;
           g.degree = f.degree;
           scan(spots f, i -> g#(i-n) = f_i);
           g)
      ---------------------------------
      -- code for method: CoherentSheaf LowerBound
      ../trunk/M2/Macaulay2/m2/varieties.m2:193:50-193:78: --source code:
      CoherentSheaf LowerBound := SumOfTwists => (F,b) -> new SumOfTwists from {F, b}
      ---------------------------------
      -- code for method: CoherentSheaf ZZ
      ../trunk/M2/Macaulay2/m2/varieties.m2:127:44-127:86: --source code:
      CoherentSheaf ZZ := CoherentSheaf => (F,n) -> sheaf(variety F, F.module ** (ring F)^{n})
      ---------------------------------
      -- code for method: Command Thing
      ../trunk/M2/Macaulay2/m2/command.m2:21:24-21:31: --source code:
      Command Thing := (x,y) -> x#0 y
      ---------------------------------
      -- code for method: Expression Expression
      ../trunk/M2/Macaulay2/m2/expressions.m2:394:44-394:68: --source code:
      Expression Expression := Adjacent => (x,y) -> new Adjacent from {x,y}
      ---------------------------------
      -- code for method: Expression Holder
      ../trunk/M2/Macaulay2/m2/expressions.m2:396:32-396:58: --source code:
      Expression Holder     := (x,y) -> new Adjacent from {x,y#0}
      ---------------------------------
      -- code for method: Expression Thing
      ../trunk/M2/Macaulay2/m2/expressions.m2:399:32-399:49: --source code:
      Expression Thing      := (x,y) -> x (expression y)
      ---------------------------------
      -- code for method: Function Thing
      ../trunk/M2/Macaulay2/m2/typicalvalues.m2:134:30-134:40: --source code:
      Function Thing := Thing => x -> (dummy x;)
      ---------------------------------
      -- code for method: GradedModule Array
      ../trunk/M2/Macaulay2/m2/gradedmodules.m2:306:45-312:6: --source code:
      GradedModule Array := GradedModule => (C,A) -> (
           if # A =!= 1 then error "expected array of length 1";
           n := A#0;
           D := new GradedModule;
           D.ring = C.ring;
           scan(spots C, i -> D#(i-n) = C#i);
           D)
      ---------------------------------
      -- code for method: HeaderType List
      ../trunk/M2/Macaulay2/m2/expressions.m2:39:26-39:40: --source code:
      HeaderType List := (T,z) -> new T from z
      ---------------------------------
      -- code for method: HeaderType Sequence
      ../trunk/M2/Macaulay2/m2/expressions.m2:40:30-40:44: --source code:
      HeaderType Sequence := (T,z) -> new T from z
      ---------------------------------
      -- code for method: Holder Expression
      ../trunk/M2/Macaulay2/m2/expressions.m2:395:32-395:58: --source code:
      Holder     Expression := (x,y) -> new Adjacent from {x#0,y}
      ---------------------------------
      -- code for method: Holder Holder
      ../trunk/M2/Macaulay2/m2/expressions.m2:397:32-397:60: --source code:
      Holder     Holder     := (x,y) -> new Adjacent from {x#0,y#0}
      ---------------------------------
      -- code for method: InexactFieldFamily Array
      ../trunk/M2/Macaulay2/m2/reals.m2:193:35-193:50: --source code:
      InexactFieldFamily Array := (T,X) -> (default T) X
      ---------------------------------
      -- code for method: InexactFieldFamily OrderedMonoid
      ../trunk/M2/Macaulay2/m2/orderedmonoidrings.m2:133:43-133:58: --source code:
      InexactFieldFamily OrderedMonoid := (T,M) -> (default T) M
      ---------------------------------
      -- code for method: Manipulator Database
      ../trunk/M2/Macaulay2/d/startup.m2.in:101:79-101:86: --source code:
           Manipulator Database := Manipulator File := Manipulator NetFile := (m,o) -> m#0 o;
      ---------------------------------
      -- code for method: Manipulator File
      ../trunk/M2/Macaulay2/d/startup.m2.in:101:79-101:86: --source code:
           Manipulator Database := Manipulator File := Manipulator NetFile := (m,o) -> m#0 o;
      ---------------------------------
      -- code for method: Manipulator NetFile
      ../trunk/M2/Macaulay2/d/startup.m2.in:101:79-101:86: --source code:
           Manipulator Database := Manipulator File := Manipulator NetFile := (m,o) -> m#0 o;
      ---------------------------------
      -- code for method: Manipulator Nothing
      ../trunk/M2/Macaulay2/d/startup.m2.in:103:38-103:41: --source code:
           Manipulator Nothing := (m,null) -> null;
      ---------------------------------
      -- code for method: MarkUpType Hypertext
      ../trunk/M2/Macaulay2/m2/html0.m2:30:31-30:46: --source code:
      MarkUpType Hypertext := (M,x) -> new M from {x}
      ---------------------------------
      -- code for method: MarkUpType Net
      ../trunk/M2/Macaulay2/m2/html0.m2:28:25-28:49: --source code:
      MarkUpType Net := (M,x) -> new M from {toString x}
      ---------------------------------
      -- code for method: MarkUpType String
      ../trunk/M2/Macaulay2/m2/html0.m2:30:31-30:46: --source code:
      MarkUpType Hypertext := (M,x) -> new M from {x}
      ---------------------------------
      -- code for method: Matrix Vector
      ../trunk/M2/Macaulay2/m2/matrix.m2:188:53-190:25: --source code:
      Matrix * Vector := Matrix Vector := Vector => (m,v) -> (
           u := m * v#0;
           new target u from {u})
      ---------------------------------
      -- code for method: Module Array
      ../trunk/M2/Macaulay2/m2/chaincomplexes.m2:901:39-908:6: --source code:
      Module Array := ChainComplex => (M,v) -> (
           if #v =!= 1 then error "expected array of length 1";
           n := v#0;
           if class n =!= ZZ then error "expected [n] with n an integer";
           C := new ChainComplex;
           C.ring = ring M;
           C#-n = M;
           C)
      ---------------------------------
      -- code for method: ProjectiveHilbertPolynomial ZZ
      ../trunk/M2/Macaulay2/m2/modules2.m2:195:41-195:83: --source code:
      ProjectiveHilbertPolynomial ZZ := (P,i) -> sum(pairs P, (n,c) -> c * binomial(n+i,n))
      ---------------------------------
      -- code for method: Ring Array
      ../trunk/M2/Macaulay2/m2/orderedmonoidrings.m2:308:47-308:63: --source code:
      Ring Array := PolynomialRing => (R,variables) -> use R monoid variables
      ---------------------------------
      -- code for method: Ring List
      ../trunk/M2/Macaulay2/m2/orderedmonoidrings.m2:309:46-309:82: --source code:
      Ring List := PolynomialRing => (R,variables) -> use R monoid (variables,Local => true)
      ---------------------------------
      -- code for method: Ring OrderedMonoid
      ../trunk/M2/Macaulay2/m2/orderedmonoidrings.m2:135:12-302:11: --source code:
           (R,M) -> (
                if not M.?RawMonoid then error "expected ordered monoid handled by the engine";
                if not R.?RawRing then error "expected coefficient ring handled by the engine";
                num := numgens M;
                (basering,flatmonoid,numallvars) := (
                     if R.?isBasic then (R,M,num)
                     else if R.?basering and R.?FlatMonoid 
                     then ( R.basering, tensor(M, R.FlatMonoid), num + R.numallvars)
                     else if instance(R,FractionField) then (R,M,num)
                     else error "internal error: expected coefficient ring to have a base ring and a flat monoid"
                     );
                local RM;
                Weyl := M.Options.WeylAlgebra =!= {};
                skews := monoidIndices(M,M.Options.SkewCommutative);
                coeffOptions := options R;
                coeffWeyl := coeffOptions =!= null and coeffOptions.WeylAlgebra =!= {};
                coeffSkew := coeffOptions =!= null and coeffOptions.SkewCommutative =!= {};
                coeffConstants := coeffOptions =!= null and coeffOptions.Constants;
                constants := false;
                if M.Options.Constants or coeffConstants then (
                     constants = true;
                     RM = new PolynomialRing from rawTowerRing(char R, flatmonoid.generatorSymbols / toString // toSequence);
                     )
                else if Weyl or coeffWeyl then (
                     if Weyl and R.?SkewCommutative then error "coefficient ring has skew commuting variables";
                     if Weyl and skews =!= {} then error "skew commutative Weyl algebra requested";
                     diffs := M.Options.WeylAlgebra;
                     if class diffs === Option then diffs = {diffs}
                     else if class diffs =!= List then error "expected list as WeylAlgebra option";
                     diffs = apply(diffs, x -> if class x === Option then toList x else x);
                     h    := select(diffs, x -> class x =!= List);
                     if #h > 1 then error "WeylAlgebra: expected at most one homogenizing variable";
                     h = monoidIndices(M,h);
                     if #h === 1 then h = h#0 else h = -1;
                     if R.?homogenize then (
                          if h == -1 then h = R.homogenize + num
                          else if R.homogenize + num =!= h then error "expected the same homogenizing variable";
                          )
                     else if coeffWeyl and h != -1 then error "coefficient Weyl algebra has no homogenizing variable";
                     diffs = select(diffs, x -> class x === List);
                     diffs = apply(diffs, x -> (
                               if class x#0 === Sequence and class x#1 === Sequence
                               then (
                                    if #(x#0) =!= #(x#1) then error "expected sequences of the same length";
                                    mingle x
                                    )
                               else toList x
                               ));
                     diffs = flatten diffs;
                     local diffs0; local diffs1;
                     diffs = pack(2,diffs);
                     diffs0 = monoidIndices(M,first\diffs);
                     diffs1 = monoidIndices(M,last\diffs);
                     if any(values tally join(diffs0,diffs1), n -> n > 1) then error "WeylAlgebra option: a variable specified more than once";
                     if coeffWeyl then (
                          diffs0 = join(diffs0, apply(R.diffs0, i -> i + num));
                          diffs1 = join(diffs1, apply(R.diffs1, i -> i + num));
                          );
                     scan(diffs0,diffs1,(x,dx) -> if not x<dx then error "expected differentiation variables to occur to the right of their variables");
                     RM = new PolynomialRing from rawWeylAlgebra(rawPolynomialRing(raw basering, raw flatmonoid),diffs0,diffs1,h);
                     RM.diffs0 = diffs0;
                     RM.diffs1 = diffs1;
                     addHook(RM, QuotientRingHook, S -> (S.diffs0 = diffs0; S.diffs1 = diffs1));
                     if h != -1 then RM.homogenize = h;
                     )
                else if skews =!= {} or R.?SkewCommutative then (
                     if R.?diffs0 then error "coefficient ring is a Weyl algebra";
                     if R.?SkewCommutative then skews = join(skews, apply(R.SkewCommutative, i -> i + num));
                     RM = new PolynomialRing from rawSkewPolynomialRing(rawPolynomialRing(raw basering, raw flatmonoid),skews);
                     RM.SkewCommutative = skews;
                     )
                else (
                     log := FunctionApplication {rawPolynomialRing, (raw basering, raw flatmonoid)};
                     RM = new PolynomialRing from value log;
                     RM#"raw creation log" = Bag {log};
                     );
                if R#?"has quotient elements" or isQuotientOf(PolynomialRing,R) then (
                     RM.RawRing = rawQuotientRing(RM.RawRing, R.RawRing);
                     RM#"has quotient elements" = true;
                     );
                RM.basering = basering;
                RM.FlatMonoid = flatmonoid;
                RM.numallvars = numallvars;
                RM.promoteDegree = (
                     if flatmonoid.Options.DegreeMap === null
                     then makepromoter degreeLength RM            -- means the degree map is zero
                     else (
                          dm := flatmonoid.Options.DegreeMap;
                          nd := flatmonoid.Options.DegreeRank;
                          degs -> apply(degs,deg -> degreePad(nd,dm deg))));
                RM.liftDegree = (
                     if flatmonoid.Options.DegreeLift === null
                     then makepromoter degreeLength R             -- lifing the zero degree map
                     else (
                          lm := flatmonoid.Options.DegreeLift;
                          degs -> apply(degs,lm)
                          ));
                RM.baseRings = append(R.baseRings,R);
                commonEngineRingInitializations RM;
                RM.monoid = M;
                if flatmonoid.?degreesRing then RM.degreesRing = flatmonoid.degreesRing;
                if flatmonoid.?degreesMonoid then RM.degreesMonoid = flatmonoid.degreesMonoid;
                RM.isCommutative = not Weyl and not RM.?SkewCommutative;
                ONE := RM#1;
                if R.?char then RM.char = R.char;
                RM _ M := (f,m) -> new R from rawCoefficient(R.RawRing, raw f, raw m);
                if constants
                then expression RM := f -> (
                     -- later we'll put in something prettier, maybe
                     toString raw f
                     )
                else expression RM := f -> (
                     (
                          (coeffs,monoms) -> (
                               if #coeffs === 0
                               then expression 0
                               else sum(coeffs,monoms, (a,m) -> expression (if a == 1 then 1 else promote(a,R)) * expression (if m == 1 then 1 else new M from m))
                               )
                          ) rawPairs(raw R, raw f)
      --             new Holder2 from {(
      --                  (coeffs,monoms) -> (
      --                       if #coeffs === 0
      --                       then expression 0
      --                       else sum(coeffs,monoms, (a,m) -> unhold expression (if a == 1 then 1 else promote(a,R)) * unhold expression (if m == 1 then 1 else new M from m))
      --                       )
      --                  ) rawPairs(raw R, raw f),
      --             f}
                );
                if M.Options.Inverses === true then (
                     denominator RM := f -> RM_( - min \ transpose exponents f );
                     numerator RM := f -> f * denominator f;
                     );
                factor RM := opts -> f -> (
                     c := 1;
                     (facs,exps) := rawFactor raw f;  -- example value: ((11, x+1, x-1, 2x+3), (1, 1, 1, 1)); constant term is first, if there is one
                     facs = apply(facs, p -> new RM from p);
                     if liftable(facs#0,R) then (
                          -- factory returns the possible constant factor in front
                          assert(exps#0 == 1);
                          c = facs#0;
                          facs = drop(facs,1);
                          exps = drop(exps,1);
                          );
                     if #facs != 0 then (facs,exps) = toSequence transpose sort transpose {toList facs, toList exps};
                     if c != 1 then (
                          -- we put the possible constant factor at the end
                          facs = append(facs,c);
                          exps = append(exps,1);
                          );
                     new Product from apply(facs,exps,(p,n) -> new Power from {p,n}));
                isPrime RM := f -> (
                     v := factor f;                               -- constant term last
                     #v === 1 and last v#0 === 1 and not isConstant first v#0
                     or
                     #v === 2 and v#0#1 === 1 and isConstant first v#0 and v#1#1 === 1
                     );
                RM.generatorSymbols = M.generatorSymbols;
                RM.generators = apply(num, i -> RM_i);
                RM.generatorExpressions = (
                     M.generatorExpressions
                     -- apply(M.generatorExpressions,RM.generators,(e,x) -> (new Holder2 from {e#0,x}))
                     );
                RM.indexSymbols = new HashTable from join(
                     if R.?indexSymbols then apply(pairs R.indexSymbols, (nm,x) -> nm => new RM from rawPromote(raw RM,raw x)) else {},
                     apply(num, i -> M.generatorSymbols#i => RM_i)
                     );
                RM.indexStrings = hashTable apply(pairs RM.indexSymbols, (k,v) -> (toString k, v));
                RM))
      ---------------------------------
      -- code for method: RingElement Array
      ../trunk/M2/Macaulay2/m2/ringmap.m2:392:28-392:59: --source code:
      RingElement Array := (r,v) -> substitute(r,matrix {toList v})
      ---------------------------------
      -- code for method: RingMap ChainComplex
      ../trunk/M2/Macaulay2/m2/chaincomplexes.m2:310:47-317:6: --source code:
      RingMap ChainComplex := ChainComplex => (f,C) -> (
           D := new ChainComplex;
           D.ring = target f;
           complete C;
           scan(spots C, i -> D#i = f C#i);
           complete C.dd;
           scan(spots C.dd, i -> D.dd#i = map(D_(i-1),D_i, f C.dd#i));
           D)
      ---------------------------------
      -- code for method: RingMap ChainComplexMap
      ../trunk/M2/Macaulay2/m2/chaincomplexes.m2:319:55-319:101: --source code:
      RingMap ChainComplexMap := ChainComplexMap => (f,phi) -> map(f target phi, f source phi, i -> f phi_i)
      ---------------------------------
      -- code for method: RingMap Ideal
      ../trunk/M2/Macaulay2/m2/ringmap.m2:394:33-394:51: --source code:
      RingMap Ideal := Ideal => (f,I) -> ideal f module I
      ---------------------------------
      -- code for method: RingMap Matrix
      ../trunk/M2/Macaulay2/m2/ringmap.m2:153:35-160:99: --source code:
      RingMap Matrix := Matrix => (p,m) -> (
           R := source p;
           S := target p;
           if R =!= ring m 
           then error "expected source of ring map to be the same as ring of matrix";
           F := p target m;
           E := p source m;
           map(F,E,map(S,rawRingMapEval(raw p, raw cover F, raw m)), Degree => p.cache.DegreeMap degree m))
      ---------------------------------
      -- code for method: RingMap Module
      ../trunk/M2/Macaulay2/m2/ringmap.m2:398:35-411:19: --source code:
      RingMap Module := Module => (f,M) -> (
           R := source f;
           S := target f;
           if R =!= ring M then error "expected module over source ring";
           if M.?relations then error "ring map applied to module with relations: use '**' or 'tensor' instead";
           if M.?generators then image f M.generators
           else (
                d := degrees M;
                e := f.cache.DegreeMap \ d;
                if R === S and d === e
                then M -- use the same module if we can
                else S^-e
                )
           )
      ---------------------------------
      -- code for method: RingMap Number
      ../trunk/M2/Macaulay2/m2/ringmap.m2:151:25-151:52: --source code:
      RingMap Number := (p,m) -> fff(p, promote(m,source p))
      ---------------------------------
      -- code for method: RingMap RingElement
      ../trunk/M2/Macaulay2/m2/ringmap.m2:143:52-149:43: --source code:
      RingMap RingElement := RingElement => fff := (p,m) -> (
           R := source p;
           S := target p;
           if R =!= ring m then (
                m = try promote(m,R) else error "ring element not in source of ring map, and not promotable to it";
                );
           promote(rawRingMapEval(raw p, raw m),S))
      ---------------------------------
      -- code for method: RingMap Vector
      ../trunk/M2/Macaulay2/m2/ringmap.m2:162:35-164:24: --source code:
      RingMap Vector := Vector => (p,m) -> (
           f := p new Matrix from m;
           new target f from f)
      ---------------------------------
      -- code for method: ScriptedFunctor Thing
      ../trunk/M2/Macaulay2/m2/gateway.m2:24:32-28:61: --source code:
      ScriptedFunctor Thing := (G,X) -> (
           if G#?argument
           then G#argument X
           else error("no method for ", toString G, " ", toString X)
           )
      ---------------------------------
      -- code for method: SelfInitializingType Thing
      ../trunk/M2/Macaulay2/m2/setup.m2:22:37-22:51: --source code:
      SelfInitializingType Thing := (T,z) -> new T from z
      ---------------------------------
      -- code for method: SheafOfRings LowerBound
      ../trunk/M2/Macaulay2/m2/varieties.m2:194:49-194:56: --source code:
      SheafOfRings LowerBound := SumOfTwists => (O,b) -> O^1 b
      ---------------------------------
      -- code for method: SheafOfRings ZZ
      ../trunk/M2/Macaulay2/m2/varieties.m2:128:43-128:50: --source code:
      SheafOfRings ZZ := CoherentSheaf => (O,n) -> O^1(n)
      ---------------------------------
      -- code for method: Thing Expression
      ../trunk/M2/Macaulay2/m2/expressions.m2:400:32-400:50: --source code:
           Thing Expression := (x,y) -> (expression x) y
      ---------------------------------
      -- code for method: Thing Thing
      ../trunk/M2/Macaulay2/m2/robust.m2:86:54-98:85: --source code:
                     installMethod(op, Thing, Thing, (x,y) -> (
                               line1 := concatenate("no method for ",
                                    if op === symbol SPACE then "adjacent objects:" else concatenate("binary operator ",op," applied to objects:")
                                    );
                               if hush then error(line1, " not displayed");
                               preY := centerString(#preX, opstring);
                               wid := max(printWidth,80);                                 -- error might occur while printWidth is narrowed
                               wid = wid - commentGuardWidth - width preX;
                               hush = true;                                       -- prevent error message recursion
                               line2 := preX | silentRobustNetWithClass(wid,ht,errorPrintingTimeLimit,x);
                               line3 := preY | silentRobustNetWithClass(wid,ht,errorPrintingTimeLimit,y);
                               hush = false;
                               error toString stack(line1,commentGuard line2,commentGuard line3))))));
      | symbol     class      value          location of symbol
      | ------     -----      -----          ------------------                            
      | op       : Keyword -- SPACE          ../trunk/M2/Macaulay2/m2/robust.m2:63:31-63:33
      | opstring : String  -- "SPACE"        ../trunk/M2/Macaulay2/m2/robust.m2:64:11-64:19
      | ht       : ZZ      -- 8              ../trunk/M2/Macaulay2/m2/robust.m2:65:11-65:13
      | preX     : String  -- "            " ../trunk/M2/Macaulay2/m2/robust.m2:66:11-66:15
      ---------------------------------
      -- code for method: WrapperType List
      ../trunk/M2/Macaulay2/m2/expressions.m2:44:27-44:41: --source code:
      WrapperType List := (T,z) -> new T from z
      ---------------------------------
      -- code for method: WrapperType Sequence
      ../trunk/M2/Macaulay2/m2/expressions.m2:45:31-45:45: --source code:
      WrapperType Sequence := (T,z) -> new T from z
      ---------------------------------
      -- code for method: WrapperType Thing
      ../trunk/M2/Macaulay2/m2/expressions.m2:46:28-46:43: --source code:
      WrapperType Thing := (T,z) -> new T from {z}
      ---------------------------------
      -- code for method: X RingElement
      ../trunk/M2/Macaulay2/m2/expressions.m2:1109:11-1109:27: --source code:
      print = x -> (<< net x << endl;)

i58 : newPackage "Foo"

o58 = Foo

o58 : Package

i59 : export "List"

o59 = {List}

o59 : List

i60 : endPackage "Foo"
--warning: symbol "List" in Core#"private dictionary" is shadowed by a symbol in Foo.Dictionary
--  use the synonym Core$List
--warning: symbol "List" in Core.Dictionary is shadowed by a symbol in Foo.Dictionary
--  use the synonym Core$List

o60 = Foo

o60 : Package

i61 : restart
Macaulay2, version 1.4.0.1
with packages: ConwayPolynomials, Elimination, IntegralClosure, LLLBases, PrimaryDecomposition,
               ReesAlgebra, TangentCone

i1 : newPackage "Foo"

o1 = Foo

o1 : Package

i2 : export "List"

o2 = {List}

o2 : List

i3 : endPackage "Foo"
--warning: symbol "List" in Core.Dictionary is shadowed by a symbol in Foo.Dictionary
--  use the synonym Core$List

o3 = Foo

o3 : Package

i4 : List

o4 = List

o4 : Symbol

i5 : Core$List

o5 = List

o5 : Type

i6 : Core$List === List

o6 = false

i7 : package List

o7 = Foo

o7 : Package

i8 : package Core$List

o8 = Core

o8 : Package

i9 : $$$=4
stdio:9:1:(3): error: invalid character
stdio:9:2:(3): error: invalid character
stdio:9:3:(3): error: invalid character
stdio:9:4:(3): error: syntax error at '='

i9 : $$$=4
stdio:9:5:(3): error: invalid character
stdio:9:6:(3): error: invalid character
stdio:9:7:(3): error: invalid character
stdio:9:8:(3): error: syntax error at '='

i9 : 

     3

o9 = 3

i10 : a$$$=4

o10 = 4

i11 : a$$$

o11 = 4

i12 : 你=4

o12 = 4

i13 : 你

o13 = 4

i14 : αβγδ=5

o14 = 5

i15 : αβγδ

o15 = 5

i16 : Core$List = 5
stdio:18:11:(3): error: assignment to protected built-in global variable 'List'

i17 : sin = 5
stdio:19:5:(3): error: assignment to protected built-in global variable 'sin'

i18 : Core$ist = 5

o18 = 5

i20 : package symbol Core$ist

o20 = User

o20 : Package

i21 : ?delete

 -- delete elements of a list

i22 : ?remove

 -- remove an entry from a hash table

Ways to use remove
==================

  * remove(HashTable,Thing), see "remove" -- remove an entry from a hash table

i23 : ?erase

 -- remove a global symbol

i24 : help erase

o24 = erase -- remove a global symbol
      *******************************

      Description
      ===========

      erase s removes the global symbol s from the symbol table.

o24 : DIV

i25 : erase ZZ
stdio:27:1:(3): error: expected a symbol

i26 : erase symbol ZZ
stdio:28:1:(3): error: symbol is in a protected dictionary

i27 : erase symbol Core$ist

i28 : apropos "angent"

o28 = {cotangentSheaf, TangentCone, tangentCone, tangentSheaf}

o28 : List

i29 : code tangentSheaf

o29 = ../trunk/M2/Macaulay2/m2/option.m2:6:20-10:34: --source code:
        (opts,f) -> args -> (
             -- Common code for functions created with >> to process options and arguments.
             uncurry(f, override (opts,args))
             )
        )
      | symbol   class              value                                                   location of symbol
      | ------   -----              -----                                                   ------------------                         
      | opts   : OptionTable     -- OptionTable{Minimize => true}                           ../trunk/M2/Macaulay2/m2/option.m2:6:4-6:8 
      | f      : FunctionClosure -- {*Function[../trunk/M2/Macaulay2/m2/methods.m2:112:70-. ../trunk/M2/Macaulay2/m2/option.m2:6:9-6:10
      | -- function f:
      | ../trunk/M2/Macaulay2/m2/methods.m2:112:70-112:102: --source code:
      |      methodFunction := new MethodFunctionWithOptions from (opts >> o -> arg -> innerMethodFunction(o,arg));
      | | symbol                class                        value                                                 location of symbol
      | | ------                -----                        -----                                                 ------------------                               
      | | methopts            : OptionTable               -- OptionTable{Binary => false                         } ../trunk/M2/Macaulay2/m2/methods.m2:109:29-109:37
      | |                                                                Dispatch => {Thing, Thing, Thing, Thing}
      | |                                                                Options => {Minimize => true}
      | |                                                                TypicalValue => Thing
      | | opts                : OptionTable               -- OptionTable{Minimize => true}                         ../trunk/M2/Macaulay2/m2/methods.m2:109:38-109:42
      | | outputs             : List                      -- {false, false, false, false}                          ../trunk/M2/Macaulay2/m2/methods.m2:109:43-109:50
      | | innerMethodFunction : CompiledFunctionClosure   -- {*Function*}                                          ../trunk/M2/Macaulay2/m2/methods.m2:111:12-111:31
      | | methodFunction      : MethodFunctionWithOptions -- tangentSheaf                                          ../trunk/M2/Macaulay2/m2/methods.m2:112:6-112:20 
      | -- option table opts:
      | OptionTable{Minimize => true}

i30 : tangentSheaf

o30 = tangentSheaf

o30 : MethodFunctionWithOptions

i31 : methods tangentSheaf

o31 = {(tangentSheaf, ProjectiveVariety)}

o31 : VerticalList

i32 : code methods tangentSheaf

o32 = -- code for method: tangentSheaf(ProjectiveVariety)
      ../trunk/M2/Macaulay2/m2/varieties.m2:258:57-258:89: --source code:
      tangentSheaf ProjectiveVariety := CoherentSheaf => opts -> (X) -> dual
      -------------------------------------------------------------------------------------------
      cotangentSheaf(X,opts)

i33 : cotangentSheaf

o33 = cotangentSheaf

o33 : MethodFunctionWithOptions

i34 : code methods cotangentSheaf

o34 = -- code for method: cotangentSheaf(ProjectiveVariety)
      ../trunk/M2/Macaulay2/m2/varieties.m2:246:59-251:11: --source code:
      cotangentSheaf ProjectiveVariety := CoherentSheaf => opts -> (cacheValue (symbol cotangentSheaf => opts)) ((X) -> (
                R := ring X;
                F := presentation R;
                om := sheaf(X, homology(vars ring F ** R,jacobian F ** R));
                if opts.Minimize then om = minimalPresentation om;
                om))
      ---------------------------------
      -- code for method: cotangentSheaf(ZZ,ProjectiveVariety)
      ../trunk/M2/Macaulay2/m2/varieties.m2:253:63-256:67: --source code:
      cotangentSheaf(ZZ,ProjectiveVariety) := CoherentSheaf => opts -> (i,X) -> (
           if X#?(cotangentSheaf,i)
           then X#(cotangentSheaf,i) 
           else X#(cotangentSheaf,i) = exteriorPower(i,cotangentSheaf(X,opts)))

i35 : newPackage "Foo"
stdio:37:1:(3): error: package Foo not reloaded; try Reload => true

i36 : newPackage "Bar"

o36 = Bar

o36 : Package

i37 : f = () -> ( x := getSymbol "x" ; QQ[x_1 .. x_10] );

i38 : g = () -> ( QQ[ symbol y _ 1 .. symbol y _ 10 ] );

i39 : export {f,g}
stdio:41:1:(2): error: expected a symbol: f

i40 : export {"f","g"}

o40 = {g, f}

o40 : List

i41 : endPackage "Bar"
stdio:43:1:(2): error: mutable unexported unset symbol(s) in package Bar: 'y'
stdio:40:24-40:25: here is the first use of 'y'

i42 : newPackage "Bar2"

o42 = Bar2

o42 : Package

i43 : f = () -> ( x := getSymbol "x" ; QQ[x_1 .. x_10] );

i44 : y = "hoo ha"

o44 = hoo ha

i45 : g = () -> ( QQ[ symbol y _ 1 .. symbol y _ 10 ] );

i46 : export {"f","g"}

o46 = {g, f}

o46 : List

i47 : endPackage "Bar"
stdio:49:1:(2): error: package not current: Bar

i48 : endPackage "Bar2"
--warning: symbol "f" in Bar.Dictionary is shadowed by a symbol in Bar2.Dictionary
--  use the synonym Bar$f
--warning: symbol "g" in Bar.Dictionary is shadowed by a symbol in Bar2.Dictionary
--  use the synonym Bar$g

o48 = Bar2

o48 : Package

i49 : f()

o49 = QQ[x , x , x , x , x , x , x , x , x , x  ]
          1   2   3   4   5   6   7   8   9   10

o49 : PolynomialRing

i50 : x_4

o50 = x
       4

o50 : QQ[x , x , x , x , x , x , x , x , x , x  ]
          1   2   3   4   5   6   7   8   9   10

i51 : g()
warning: clearing value of symbol y to allow access to subscripted variables based on it
       : debug with expression   debug 9371   or with command line option   --debug 9371

o51 = QQ[y , y , y , y , y , y , y , y , y , y  ]
          1   2   3   4   5   6   7   8   9   10

o51 : PolynomialRing

i52 : y_5

o52 = y
       5

o52 : IndexedVariable

i53 : g()

o53 = QQ[y , y , y , y , y , y , y , y , y , y  ]
          1   2   3   4   5   6   7   8   9   10

o53 : PolynomialRing

i54 : debug Bar2
--warning: symbol "f" in Bar.Dictionary is shadowed by a symbol in Bar2#"private dictionary"
--  use the synonym Bar$f
--warning: symbol "g" in Bar.Dictionary is shadowed by a symbol in Bar2#"private dictionary"
--  use the synonym Bar$g
--warning: symbol "y" in User#"private dictionary" is shadowed by a symbol in Bar2#"private dictionary"
--  use the synonym y$0

i55 : y = "ho"

o55 = ho

i56 : g()
warning: clearing value of symbol y to allow access to subscripted variables based on it
       : debug with expression   debug 9371   or with command line option   --debug 9371

o56 = QQ[y , y , y , y , y , y , y , y , y , y  ]
          1   2   3   4   5   6   7   8   9   10

o56 : PolynomialRing

i57 : y = "ho"

o57 = ho

i58 : y = symbol y

o58 = y

o58 : Symbol

i59 : g()

o59 = QQ[y , y , y , y , y , y , y , y , y , y  ]
          1   2   3   4   5   6   7   8   9   10

o59 : PolynomialRing

i60 : f()

o60 = QQ[x , x , x , x , x , x , x , x , x , x  ]
          1   2   3   4   5   6   7   8   9   10

o60 : PolynomialRing

i61 : x_4

o61 = x
       4

o61 : QQ[x , x , x , x , x , x , x , x , x , x  ]
          1   2   3   4   5   6   7   8   9   10

i62 : ring oo

o62 = QQ[x , x , x , x , x , x , x , x , x , x  ]
          1   2   3   4   5   6   7   8   9   10

o62 : PolynomialRing

i64 : sub(x_4^2 , {x_4 => 4})

o64 = 16

o64 : QQ[x , x , x , x , x , x , x , x , x , x  ]
          1   2   3   4   5   6   7   8   9   10

i65 : restart
Macaulay2, version 1.4.0.1
with packages: ConwayPolynomials, Elimination, IntegralClosure, LLLBases, PrimaryDecomposition,
               ReesAlgebra, TangentCone

i1 : A = QQ[x]

o1 = A

o1 : PolynomialRing

i2 : B =QQ[x]

o2 = B

o2 : PolynomialRing

i3 : C = QQ( monoid [t] )

o3 = C

o3 : PolynomialRing

i4 : t

o4 = t

o4 : C

i5 : restart
Macaulay2, version 1.4.0.1
with packages: ConwayPolynomials, Elimination, IntegralClosure, LLLBases, PrimaryDecomposition,
               ReesAlgebra, TangentCone

i1 : C := QQ( monoid [t] )

o1 = QQ[t]

o1 : PolynomialRing

i2 : t

o2 = t

o2 : Symbol

i3 : C

o3 = QQ[t]

o3 : PolynomialRing

i4 : use C

o4 = QQ[t]

o4 : PolynomialRing

i5 : t

o5 = t

o5 : QQ[t]

i6 : R = QQ[a..d]

o6 = R

o6 : PolynomialRing

i7 : poincare coker vars R

                2     3    4
o7 = 1 - 4T + 6T  - 4T  + T

o7 : ZZ[T]

i8 : T

o8 = T

o8 : Symbol

i9 : use ring o7

o9 = ZZ[T]

o9 : PolynomialRing

i10 : T

o10 = T

o10 : ZZ[T]

i11 : gens ring o7

o11 = {T}

o11 : List

i12 : (gens ring o7)#0

o12 = T

o12 : ZZ[T]

i13 : (ring o7)_0

o13 = T

o13 : ZZ[T]

i14 : gns := gens ring o7

o14 = {T}

o14 : List

i15 : gns#0

o15 = T

o15 : ZZ[T]

i16 : poincare coker vars R

                 2     3    4
o16 = 1 - 4T + 6T  - 4T  + T

o16 : ZZ[T]

i17 : poincare coker {b,c}
stdio:17:10:(3): error: no method found for applying cokernel to:
     argument   :  {b, c} (of class List)

i18 : use R

o18 = R

o18 : PolynomialRing

i19 : poincare coker matrix {{b,c}}

                2
o19 = 1 - 2T + T

o19 : ZZ[T]

i20 : poincare coker vars R

                 2     3    4
o20 = 1 - 4T + 6T  - 4T  + T

o20 : ZZ[T]

i21 : o20 + o19

                 2     3    4
o21 = 2 - 6T + 7T  - 4T  + T

o21 : ZZ[T]

i22 : degreesRing R

o22 = ZZ[T]

o22 : PolynomialRing

i23 : ?genericMatrix 

  * Usage:genericMatrix(R,r,m,n)
  * Inputs:
      * R, a ring
      * r, a ring element, which is a variable in the ring R (this input is optional)
      * m, an integer
      * n, an integer
  * Outputs:
      * a matrix, with m rows and n columns whose entries are variables in the ring R starting
        with r

Ways to use genericMatrix
=========================

  * genericMatrix(Ring,RingElement,ZZ,ZZ), see "genericMatrix" -- make a generic matrix of
    variables
  * genericMatrix(Ring,ZZ,ZZ), see "genericMatrix" -- make a generic matrix of variables

i24 : 